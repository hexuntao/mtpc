import type { AnyZodSchema, ResourceDefinition } from '@mtpc/core';
import { toPascalCase } from '@mtpc/shared';
import type { GeneratedFile, TypeScriptOptions } from '../types.js';

/**
 * Generate TypeScript types from resources
 */
export function generateTypeScriptTypes(
  resources: ResourceDefinition[],
  options: TypeScriptOptions = {}
): GeneratedFile {
  const {
    outputFile = 'types.ts',
    includeZodSchemas = true,
    includeEntityTypes = true,
    includeInputTypes = true,
  } = options;

  const lines: string[] = ['// Auto-generated by @mtpc/codegen', '// Do not edit manually', ''];

  if (includeZodSchemas) {
    lines.push("import { z } from 'zod';");
    lines.push('');
  }

  for (const resource of resources) {
    const typeName = toPascalCase(resource.name);

    lines.push(`// ============== ${typeName} ==============`);
    lines.push('');

    if (includeZodSchemas) {
      lines.push(`/**`);
      lines.push(` * ${typeName} schema`);
      lines.push(` */`);
      lines.push(`export const ${typeName}Schema = ${zodSchemaToString(resource.schema)};`);
      lines.push('');
    }

    if (includeEntityTypes) {
      lines.push(`/**`);
      lines.push(` * ${typeName} entity type`);
      lines.push(` */`);

      if (includeZodSchemas) {
        lines.push(`export type ${typeName} = z.infer<typeof ${typeName}Schema>;`);
      } else {
        lines.push(`export interface ${typeName} ${zodSchemaToInterface(resource.schema)}`);
      }
      lines.push('');
    }

    if (includeInputTypes) {
      lines.push(`/**`);
      lines.push(` * ${typeName} create input`);
      lines.push(` */`);

      if (includeZodSchemas) {
        lines.push(
          `export const ${typeName}CreateSchema = ${zodSchemaToString(resource.createSchema)};`
        );
        lines.push(`export type ${typeName}CreateInput = z.infer<typeof ${typeName}CreateSchema>;`);
      } else {
        lines.push(
          `export interface ${typeName}CreateInput ${zodSchemaToInterface(resource.createSchema)}`
        );
      }
      lines.push('');

      lines.push(`/**`);
      lines.push(` * ${typeName} update input`);
      lines.push(` */`);

      if (includeZodSchemas) {
        lines.push(
          `export const ${typeName}UpdateSchema = ${zodSchemaToString(resource.updateSchema)};`
        );
        lines.push(`export type ${typeName}UpdateInput = z.infer<typeof ${typeName}UpdateSchema>;`);
      } else {
        lines.push(
          `export interface ${typeName}UpdateInput ${zodSchemaToInterface(resource.updateSchema, true)}`
        );
      }
      lines.push('');
    }
  }

  // Generate unified exports
  lines.push('// ============== Unified Exports ==============');
  lines.push('');
  lines.push('/**');
  lines.push(' * All entity types');
  lines.push(' */');
  lines.push('export type EntityTypes = {');

  for (const resource of resources) {
    const typeName = toPascalCase(resource.name);
    lines.push(`  ${resource.name}: ${typeName};`);
  }

  lines.push('};');
  lines.push('');

  lines.push('/**');
  lines.push(' * Entity type by name');
  lines.push(' */');
  lines.push('export type EntityType<T extends keyof EntityTypes> = EntityTypes[T];');
  lines.push('');

  return {
    path: outputFile,
    content: lines.join('\n'),
    type: 'typescript',
  };
}

/**
 * Convert Zod schema to string representation
 */
function zodSchemaToString(schema: AnyZodSchema, indent: number = 0): string {
  const typeName = schema._def.typeName;
  const padding = '  '.repeat(indent);

  switch (typeName) {
    case 'ZodObject': {
      const shape = schema._def.shape();
      const lines = ['z.object({'];

      for (const [key, value] of Object.entries(shape)) {
        const fieldSchema = zodSchemaToString(value as AnyZodSchema, indent + 1);
        lines.push(`${padding}  ${key}: ${fieldSchema},`);
      }

      lines.push(`${padding}})`);
      return lines.join('\n');
    }

    case 'ZodString': {
      const checks = schema._def.checks ?? [];
      let result = 'z.string()';

      for (const check of checks) {
        switch (check.kind) {
          case 'min':
            result += `.min(${check.value})`;
            break;
          case 'max':
            result += `.max(${check.value})`;
            break;
          case 'email':
            result += '.email()';
            break;
          case 'uuid':
            result += '.uuid()';
            break;
          case 'url':
            result += '.url()';
            break;
        }
      }

      return result;
    }

    case 'ZodNumber': {
      const checks = schema._def.checks ?? [];
      let result = 'z.number()';

      for (const check of checks) {
        switch (check.kind) {
          case 'min':
            result += `.min(${check.value})`;
            break;
          case 'max':
            result += `.max(${check.value})`;
            break;
          case 'int':
            result += '.int()';
            break;
        }
      }

      return result;
    }

    case 'ZodBoolean':
      return 'z.boolean()';

    case 'ZodDate':
      return 'z.date()';

    case 'ZodArray':
      return `z.array(${zodSchemaToString(schema._def.type, indent)})`;

    case 'ZodOptional':
      return `${zodSchemaToString(schema._def.innerType, indent)}.optional()`;

    case 'ZodNullable':
      return `${zodSchemaToString(schema._def.innerType, indent)}.nullable()`;

    case 'ZodDefault': {
      const defaultVal = JSON.stringify(schema._def.defaultValue());
      return `${zodSchemaToString(schema._def.innerType, indent)}.default(${defaultVal})`;
    }

    case 'ZodEnum': {
      const values = schema._def.values.map((v: string) => `'${v}'`).join(', ');
      return `z.enum([${values}])`;
    }

    case 'ZodRecord':
      return `z.record(${zodSchemaToString(schema._def.valueType, indent)})`;

    default:
      return 'z.unknown()';
  }
}

/**
 * Convert Zod schema to TypeScript interface
 */
function zodSchemaToInterface(schema: AnyZodSchema, partial: boolean = false): string {
  if (schema._def.typeName !== 'ZodObject') {
    return '{}';
  }

  const shape = schema._def.shape();
  const lines = ['{'];

  for (const [key, value] of Object.entries(shape)) {
    const tsType = zodTypeToTypeScript(value as AnyZodSchema);
    const optional = partial || isOptional(value as AnyZodSchema) ? '?' : '';
    lines.push(`  ${key}${optional}: ${tsType};`);
  }

  lines.push('}');
  return lines.join('\n');
}

/**
 * Convert Zod type to TypeScript type
 */
function zodTypeToTypeScript(schema: AnyZodSchema): string {
  const typeName = schema._def.typeName;

  switch (typeName) {
    case 'ZodString':
      return 'string';
    case 'ZodNumber':
      return 'number';
    case 'ZodBoolean':
      return 'boolean';
    case 'ZodDate':
      return 'Date';
    case 'ZodArray':
      return `${zodTypeToTypeScript(schema._def.type)}[]`;
    case 'ZodObject':
      return zodSchemaToInterface(schema);
    case 'ZodOptional':
      return `${zodTypeToTypeScript(schema._def.innerType)} | undefined`;
    case 'ZodNullable':
      return `${zodTypeToTypeScript(schema._def.innerType)} | null`;
    case 'ZodDefault':
      return zodTypeToTypeScript(schema._def.innerType);
    case 'ZodEnum':
      return schema._def.values.map((v: string) => `'${v}'`).join(' | ');
    case 'ZodRecord':
      return `Record<string, ${zodTypeToTypeScript(schema._def.valueType)}>`;
    default:
      return 'unknown';
  }
}

/**
 * Check if Zod type is optional
 */
function isOptional(schema: AnyZodSchema): boolean {
  return schema._def.typeName === 'ZodOptional' || schema._def.typeName === 'ZodNullable';
}

/**
 * Generate index file for types
 */
export function generateTypesIndex(resources: ResourceDefinition[]): GeneratedFile {
  const lines: string[] = [
    '// Auto-generated by @mtpc/codegen',
    '// Do not edit manually',
    '',
    "export * from './types.js';",
    "export * from './permissions.js';",
    "export * from './permission-types.js';",
    "export * from './metadata.js';",
    '',
  ];

  return {
    path: 'index.ts',
    content: lines.join('\n'),
    type: 'typescript',
  };
}
