import type { AnyZodSchema, ResourceDefinition } from '@mtpc/core';
import { toPascalCase } from '@mtpc/shared';
import type { GeneratedFile, TypeScriptOptions } from '../types.js';

/**
 * 从资源定义生成 TypeScript 类型
 *
 * 根据资源定义生成类型安全的 TypeScript 代码，包括：
 * - Zod Schema 定义（可选）
 * - 实体类型（Entity Types）
 * - 创建输入类型（Create Input Types）
 * - 更新输入类型（Update Input Types）
 * - 统一的类型导出
 *
 * @param resources - 资源定义数组
 * @param options - TypeScript 生成选项
 * @returns 生成的 TypeScript 类型文件
 *
 * @example
 * ```typescript
 * const result = generateTypeScriptTypes(
 *   [userResource, postResource],
 *   {
 *     outputFile: 'types.ts',
 *     includeZodSchemas: true,
 *     includeEntityTypes: true,
 *     includeInputTypes: true
 *   }
 * );
 * ```
 */
export function generateTypeScriptTypes(
  resources: ResourceDefinition[],
  options: TypeScriptOptions = {}
): GeneratedFile {
  const {
    outputFile = 'types.ts',
    includeZodSchemas = true,
    includeEntityTypes = true,
    includeInputTypes = true,
  } = options;

  const lines: string[] = ['// Auto-generated by @mtpc/codegen', '// Do not edit manually', ''];

  if (includeZodSchemas) {
    lines.push("import { z } from 'zod';");
    lines.push('');
  }

  for (const resource of resources) {
    const typeName = toPascalCase(resource.name);

    lines.push(`// ============== ${typeName} ==============`);
    lines.push('');

    if (includeZodSchemas) {
      lines.push(`/**`);
      lines.push(` * ${typeName} schema`);
      lines.push(` * ${typeName} 的 Zod Schema 定义`);
      lines.push(` */`);
      lines.push(`export const ${typeName}Schema = ${zodSchemaToString(resource.schema)};`);
      lines.push('');
    }

    if (includeEntityTypes) {
      lines.push(`/**`);
      lines.push(` * ${typeName} entity type`);
      lines.push(` * ${typeName} 实体类型`);
      lines.push(` */`);

      if (includeZodSchemas) {
        lines.push(`export type ${typeName} = z.infer<typeof ${typeName}Schema>;`);
      } else {
        lines.push(`export interface ${typeName} ${zodSchemaToInterface(resource.schema)}`);
      }
      lines.push('');
    }

    if (includeInputTypes) {
      lines.push(`/**`);
      lines.push(` * ${typeName} create input`);
      lines.push(` * ${typeName} 创建输入类型`);
      lines.push(` */`);

      if (includeZodSchemas) {
        lines.push(
          `export const ${typeName}CreateSchema = ${zodSchemaToString(resource.createSchema)};`
        );
        lines.push(`export type ${typeName}CreateInput = z.infer<typeof ${typeName}CreateSchema>;`);
      } else {
        lines.push(
          `export interface ${typeName}CreateInput ${zodSchemaToInterface(resource.createSchema)}`
        );
      }
      lines.push('');

      lines.push(`/**`);
      lines.push(` * ${typeName} update input`);
      lines.push(` * ${typeName} 更新输入类型（所有字段可选）`);
      lines.push(` */`);

      if (includeZodSchemas) {
        lines.push(
          `export const ${typeName}UpdateSchema = ${zodSchemaToString(resource.updateSchema)};`
        );
        lines.push(`export type ${typeName}UpdateInput = z.infer<typeof ${typeName}UpdateSchema>;`);
      } else {
        lines.push(
          `export interface ${typeName}UpdateInput ${zodSchemaToInterface(resource.updateSchema, true)}`
        );
      }
      lines.push('');
    }
  }

  // Generate unified exports
  lines.push('// ============== Unified Exports ==============');
  lines.push('// ============== 统一导出 ==============');
  lines.push('');
  lines.push('/**');
  lines.push(' * All entity types');
  lines.push(' * 所有实体类型的映射');
  lines.push(' */');
  lines.push('export type EntityTypes = {');

  for (const resource of resources) {
    const typeName = toPascalCase(resource.name);
    lines.push(`  ${resource.name}: ${typeName};`);
  }

  lines.push('};');
  lines.push('');

  lines.push('/**');
  lines.push(' * Entity type by name');
  lines.push(' * 根据资源名称获取实体类型');
  lines.push(' */');
  lines.push('export type EntityType<T extends keyof EntityTypes> = EntityTypes[T];');
  lines.push('');

  return {
    path: outputFile,
    content: lines.join('\n'),
    type: 'typescript',
  };
}

/**
 * 将 Zod Schema 转换为字符串表示
 *
 * 递归遍历 Zod Schema 结构，生成对应的 Zod 构建代码字符串。
 * 支持各种 Zod 类型，包括对象、字符串、数字、数组、可选等。
 *
 * @param schema - Zod Schema 对象
 * @param indent - 缩进级别
 * @returns Zod Schema 字符串表示
 *
 * @example
 * ```typescript
 * zodSchemaToString(z.object({ name: z.string().min(1) }))
 * // 返回: "z.object({\n  name: z.string().min(1),\n})"
 * ```
 */
function zodSchemaToString(schema: AnyZodSchema, indent: number = 0): string {
  const typeName = schema._def.typeName;
  const padding = '  '.repeat(indent);

  switch (typeName) {
    case 'ZodObject': {
      const shape = schema._def.shape();
      const lines = ['z.object({'];

      for (const [key, value] of Object.entries(shape)) {
        const fieldSchema = zodSchemaToString(value as AnyZodSchema, indent + 1);
        lines.push(`${padding}  ${key}: ${fieldSchema},`);
      }

      lines.push(`${padding}})`);
      return lines.join('\n');
    }

    case 'ZodString': {
      const checks = schema._def.checks ?? [];
      let result = 'z.string()';

      for (const check of checks) {
        switch (check.kind) {
          case 'min':
            result += `.min(${check.value})`;
            break;
          case 'max':
            result += `.max(${check.value})`;
            break;
          case 'email':
            result += '.email()';
            break;
          case 'uuid':
            result += '.uuid()';
            break;
          case 'url':
            result += '.url()';
            break;
        }
      }

      return result;
    }

    case 'ZodNumber': {
      const checks = schema._def.checks ?? [];
      let result = 'z.number()';

      for (const check of checks) {
        switch (check.kind) {
          case 'min':
            result += `.min(${check.value})`;
            break;
          case 'max':
            result += `.max(${check.value})`;
            break;
          case 'int':
            result += '.int()';
            break;
        }
      }

      return result;
    }

    case 'ZodBoolean':
      return 'z.boolean()';

    case 'ZodDate':
      return 'z.date()';

    case 'ZodArray':
      return `z.array(${zodSchemaToString(schema._def.type, indent)})`;

    case 'ZodOptional':
      return `${zodSchemaToString(schema._def.innerType, indent)}.optional()`;

    case 'ZodNullable':
      return `${zodSchemaToString(schema._def.innerType, indent)}.nullable()`;

    case 'ZodDefault': {
      const defaultVal = JSON.stringify(schema._def.defaultValue());
      return `${zodSchemaToString(schema._def.innerType, indent)}.default(${defaultVal})`;
    }

    case 'ZodEnum': {
      const values = schema._def.values.map((v: string) => `'${v}'`).join(', ');
      return `z.enum([${values}])`;
    }

    case 'ZodRecord':
      return `z.record(${zodSchemaToString(schema._def.valueType, indent)})`;

    default:
      return 'z.unknown()';
  }
}

/**
 * 将 Zod Schema 转换为 TypeScript 接口
 *
 * 生成纯 TypeScript 接口定义，不依赖 Zod 类型推断。
 * 可选择生成部分类型（所有字段可选），用于更新操作。
 *
 * @param schema - Zod Schema 对象
 * @param partial - 是否生成部分类型（所有字段可选）
 * @returns TypeScript 接口字符串
 *
 * @example
 * ```typescript
 * zodSchemaToInterface(z.object({ name: z.string() }))
 * // 返回: "{\n  name: string;\n}"
 * ```
 */
function zodSchemaToInterface(schema: AnyZodSchema, partial: boolean = false): string {
  if (schema._def.typeName !== 'ZodObject') {
    return '{}';
  }

  const shape = schema._def.shape();
  const lines = ['{'];

  for (const [key, value] of Object.entries(shape)) {
    const tsType = zodTypeToTypeScript(value as AnyZodSchema);
    const optional = partial || isOptional(value as AnyZodSchema) ? '?' : '';
    lines.push(`  ${key}${optional}: ${tsType};`);
  }

  lines.push('}');
  return lines.join('\n');
}

/**
 * 将 Zod 类型转换为 TypeScript 类型
 *
 * 递归转换 Zod 类型定义到对应的 TypeScript 类型字符串。
 *
 * @param schema - Zod Schema 对象
 * @returns TypeScript 类型字符串
 */
function zodTypeToTypeScript(schema: AnyZodSchema): string {
  const typeName = schema._def.typeName;

  switch (typeName) {
    case 'ZodString':
      return 'string';
    case 'ZodNumber':
      return 'number';
    case 'ZodBoolean':
      return 'boolean';
    case 'ZodDate':
      return 'Date';
    case 'ZodArray':
      return `${zodTypeToTypeScript(schema._def.type)}[]`;
    case 'ZodObject':
      return zodSchemaToInterface(schema);
    case 'ZodOptional':
      return `${zodTypeToTypeScript(schema._def.innerType)} | undefined`;
    case 'ZodNullable':
      return `${zodTypeToTypeScript(schema._def.innerType)} | null`;
    case 'ZodDefault':
      return zodTypeToTypeScript(schema._def.innerType);
    case 'ZodEnum':
      return schema._def.values.map((v: string) => `'${v}'`).join(' | ');
    case 'ZodRecord':
      return `Record<string, ${zodTypeToTypeScript(schema._def.valueType)}>`;
    default:
      return 'unknown';
  }
}

/**
 * 检查 Zod 类型是否为可选
 *
 * 判断给定的 Zod Schema 是否被 Optional 或 Nullable 包装。
 *
 * @param schema - Zod Schema 对象
 * @returns 是否为可选类型
 */
function isOptional(schema: AnyZodSchema): boolean {
  return schema._def.typeName === 'ZodOptional' || schema._def.typeName === 'ZodNullable';
}

/**
 * 生成类型索引文件
 *
 * 创建一个统一的导出索引文件，导出所有类型相关的文件。
 * 生成的 index.ts 会重新导出：
 * - types.ts（类型定义）
 * - permissions.ts（权限常量）
 * - permission-types.ts（权限类型）
 * - metadata.ts（元数据）
 *
 * @returns 生成的索引文件
 *
 * @example
 * 生成的 index.ts：
 * ```typescript
 * export * from './types.js';
 * export * from './permissions.js';
 * export * from './permission-types.js';
 * export * from './metadata.js';
 * ```
 */
export function generateTypesIndex(): GeneratedFile {
  const lines: string[] = [
    '// Auto-generated by @mtpc/codegen',
    '// Do not edit manually',
    '',
    "export * from './types.js';",
    "export * from './permissions.js';",
    "export * from './permission-types.js';",
    "export * from './metadata.js';",
    '',
  ];

  return {
    path: 'index.ts',
    content: lines.join('\n'),
    type: 'typescript',
  };
}
