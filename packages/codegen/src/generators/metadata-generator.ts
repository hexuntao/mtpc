import type { Permission, ResourceDefinition } from '@mtpc/core';
import { compileResourcePermissions } from '@mtpc/core';
import type { GeneratedFile, MetadataOptions } from '../types.js';

/**
 * Resource metadata for UI consumption
 */
interface ResourceMetadataOutput {
  name: string;
  displayName: string;
  pluralName: string;
  description?: string;
  icon?: string;
  group?: string;
  hidden: boolean;
  features: {
    create: boolean;
    read: boolean;
    update: boolean;
    delete: boolean;
    list: boolean;
  };
  permissions: Array<{
    code: string;
    action: string;
    description?: string;
  }>;
  fields: Array<{
    name: string;
    type: string;
    required: boolean;
  }>;
}

/**
 * Generate metadata JSON
 */
export function generateMetadata(
  resources: ResourceDefinition[],
  options: MetadataOptions = {}
): GeneratedFile {
  const {
    outputFile = 'metadata.json',
    includePermissions = true,
    includeFeatures = true,
  } = options;

  const metadata: ResourceMetadataOutput[] = resources.map(resource => {
    const permissions = compileResourcePermissions(resource.name, resource.permissions);

    return {
      name: resource.name,
      displayName: resource.metadata.displayName ?? resource.name,
      pluralName: resource.metadata.pluralName ?? resource.name + 's',
      description: resource.metadata.description,
      icon: resource.metadata.icon,
      group: resource.metadata.group,
      hidden: resource.metadata.hidden ?? false,
      features: includeFeatures
        ? {
            create: resource.features.create,
            read: resource.features.read,
            update: resource.features.update,
            delete: resource.features.delete,
            list: resource.features.list,
          }
        : (undefined as any),
      permissions: includePermissions
        ? permissions.map(p => ({
            code: p.code,
            action: p.action,
            description: p.description,
          }))
        : [],
      fields: extractFields(resource.schema),
    };
  });

  return {
    path: outputFile,
    content: JSON.stringify({ resources: metadata }, null, 2),
    type: 'json',
  };
}

/**
 * Generate TypeScript metadata file
 */
export function generateMetadataTS(
  resources: ResourceDefinition[],
  options: MetadataOptions = {}
): GeneratedFile {
  const { outputFile = 'metadata.ts' } = options;

  const lines: string[] = [
    '// Auto-generated by @mtpc/codegen',
    '// Do not edit manually',
    '',
    '/**',
    ' * Resource metadata type',
    ' */',
    'export interface ResourceMetadata {',
    '  name: string;',
    '  displayName: string;',
    '  pluralName: string;',
    '  description?: string;',
    '  icon?: string;',
    '  group?: string;',
    '  hidden: boolean;',
    '  features: {',
    '    create: boolean;',
    '    read: boolean;',
    '    update: boolean;',
    '    delete: boolean;',
    '    list: boolean;',
    '  };',
    '  permissions: Array<{',
    '    code: string;',
    '    action: string;',
    '    description?: string;',
    '  }>;',
    '  fields: Array<{',
    '    name: string;',
    '    type: string;',
    '    required: boolean;',
    '  }>;',
    '}',
    '',
    '/**',
    ' * All resources metadata',
    ' */',
    'export const resourceMetadata: Record<string, ResourceMetadata> = {',
  ];

  for (const resource of resources) {
    const permissions = compileResourcePermissions(resource.name, resource.permissions);
    const fields = extractFields(resource.schema);

    lines.push(`  '${resource.name}': {`);
    lines.push(`    name: '${resource.name}',`);
    lines.push(`    displayName: '${resource.metadata.displayName ?? resource.name}',`);
    lines.push(`    pluralName: '${resource.metadata.pluralName ?? resource.name + 's'}',`);

    if (resource.metadata.description) {
      lines.push(`    description: '${resource.metadata.description}',`);
    }
    if (resource.metadata.icon) {
      lines.push(`    icon: '${resource.metadata.icon}',`);
    }
    if (resource.metadata.group) {
      lines.push(`    group: '${resource.metadata.group}',`);
    }

    lines.push(`    hidden: ${resource.metadata.hidden ?? false},`);
    lines.push('    features: {');
    lines.push(`      create: ${resource.features.create},`);
    lines.push(`      read: ${resource.features.read},`);
    lines.push(`      update: ${resource.features.update},`);
    lines.push(`      delete: ${resource.features.delete},`);
    lines.push(`      list: ${resource.features.list},`);
    lines.push('    },');

    lines.push('    permissions: [');
    for (const perm of permissions) {
      lines.push(
        `      { code: '${perm.code}', action: '${perm.action}'${perm.description ? `, description: '${perm.description}'` : ''} },`
      );
    }
    lines.push('    ],');

    lines.push('    fields: [');
    for (const field of fields) {
      lines.push(
        `      { name: '${field.name}', type: '${field.type}', required: ${field.required} },`
      );
    }
    lines.push('    ],');

    lines.push('  },');
  }

  lines.push('};');
  lines.push('');
  lines.push('/**');
  lines.push(' * Get resource metadata by name');
  lines.push(' */');
  lines.push('export function getResourceMetadata(name: string): ResourceMetadata | undefined {');
  lines.push('  return resourceMetadata[name];');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Get all visible resources');
  lines.push(' */');
  lines.push('export function getVisibleResources(): ResourceMetadata[] {');
  lines.push('  return Object.values(resourceMetadata).filter(r => !r.hidden);');
  lines.push('}');
  lines.push('');
  lines.push('/**');
  lines.push(' * Get resources by group');
  lines.push(' */');
  lines.push('export function getResourcesByGroup(group: string): ResourceMetadata[] {');
  lines.push('  return Object.values(resourceMetadata).filter(r => r.group === group);');
  lines.push('}');
  lines.push('');

  return {
    path: outputFile,
    content: lines.join('\n'),
    type: 'typescript',
  };
}

/**
 * Extract fields from Zod schema
 */
function extractFields(schema: any): Array<{ name: string; type: string; required: boolean }> {
  const fields: Array<{ name: string; type: string; required: boolean }> = [];

  if (schema._def.typeName !== 'ZodObject') {
    return fields;
  }

  const shape = schema._def.shape();

  for (const [name, value] of Object.entries(shape)) {
    const zodType = value as any;
    fields.push({
      name,
      type: getZodTypeName(zodType),
      required: !isOptional(zodType),
    });
  }

  return fields;
}

/**
 * Get Zod type name
 */
function getZodTypeName(schema: any): string {
  const typeName = schema._def.typeName;

  switch (typeName) {
    case 'ZodString':
      return 'string';
    case 'ZodNumber':
      return 'number';
    case 'ZodBoolean':
      return 'boolean';
    case 'ZodDate':
      return 'date';
    case 'ZodArray':
      return `array<${getZodTypeName(schema._def.type)}>`;
    case 'ZodObject':
      return 'object';
    case 'ZodOptional':
    case 'ZodNullable':
    case 'ZodDefault':
      return getZodTypeName(schema._def.innerType ?? schema._def.type);
    case 'ZodEnum':
      return 'enum';
    case 'ZodRecord':
      return 'record';
    default:
      return 'unknown';
  }
}

/**
 * Check if Zod type is optional
 */
function isOptional(schema: any): boolean {
  const typeName = schema._def.typeName;
  return typeName === 'ZodOptional' || typeName === 'ZodNullable' || typeName === 'ZodDefault';
}
