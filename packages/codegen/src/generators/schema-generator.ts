import type { ResourceDefinition } from '@mtpc/core';
import { toSnakeCase } from '@mtpc/shared';
import type { GeneratedFile, SchemaOptions } from '../types.js';

/**
 * Generate Drizzle schema file
 */
export function generateDrizzleSchema(
  resources: ResourceDefinition[],
  options: SchemaOptions = {}
): GeneratedFile {
  const { outputFile = 'schema.ts', tenantColumn = 'tenant_id', timestamps = true } = options;

  const lines: string[] = [
    '// Auto-generated by @mtpc/codegen',
    '// Do not edit manually',
    '',
    'import {',
    '  pgTable,',
    '  uuid,',
    '  text,',
    '  varchar,',
    '  integer,',
    '  boolean,',
    '  timestamp,',
    '  jsonb,',
    '  index,',
    "} from 'drizzle-orm/pg-core';",
    '',
  ];

  for (const resource of resources) {
    const tableName = toSnakeCase(resource.name);
    const varName = resource.name + 'Table';

    lines.push(`/**`);
    lines.push(` * ${resource.metadata.displayName ?? resource.name} table`);
    lines.push(` */`);
    lines.push(`export const ${varName} = pgTable('${tableName}', {`);

    // ID column
    lines.push("  id: uuid('id').primaryKey().defaultRandom(),");

    // Tenant column
    lines.push(`  tenantId: uuid('${tenantColumn}').notNull(),`);

    // Resource fields
    const fields = extractSchemaFields(resource.schema);
    for (const field of fields) {
      if (field.name === 'id' || field.name === 'tenantId') continue;

      const columnName = toSnakeCase(field.name);
      const columnDef = fieldToColumn(field);
      lines.push(`  ${field.name}: ${columnDef},`);
    }

    // Timestamps
    if (timestamps) {
      lines.push(
        "  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull(),"
      );
      lines.push(
        "  updatedAt: timestamp('updated_at', { withTimezone: true }).defaultNow().notNull(),"
      );
    }

    // Audit fields if enabled
    if (resource.features.advanced.audit) {
      lines.push("  createdBy: uuid('created_by'),");
      lines.push("  updatedBy: uuid('updated_by'),");
    }

    // Soft delete if enabled
    if (resource.features.advanced.softDelete) {
      lines.push("  deletedAt: timestamp('deleted_at', { withTimezone: true }),");
      lines.push("  deletedBy: uuid('deleted_by'),");
    }

    lines.push('}, (table) => ({');
    lines.push(`  tenantIdx: index('${tableName}_tenant_idx').on(table.tenantId),`);
    lines.push('}));');
    lines.push('');
  }

  // Export all tables
  lines.push('/**');
  lines.push(' * All tables');
  lines.push(' */');
  lines.push('export const tables = {');

  for (const resource of resources) {
    lines.push(`  ${resource.name}: ${resource.name}Table,`);
  }

  lines.push('};');
  lines.push('');

  return {
    path: outputFile,
    content: lines.join('\n'),
    type: 'typescript',
  };
}

/**
 * Extract fields from schema
 */
function extractSchemaFields(schema: any): Array<{
  name: string;
  type: string;
  required: boolean;
  maxLength?: number;
  isUuid?: boolean;
}> {
  const fields: Array<{
    name: string;
    type: string;
    required: boolean;
    maxLength?: number;
    isUuid?: boolean;
  }> = [];

  if (schema._def.typeName !== 'ZodObject') {
    return fields;
  }

  const shape = schema._def.shape();

  for (const [name, value] of Object.entries(shape)) {
    const zodType = unwrap(value as any);
    const checks = zodType._def.checks ?? [];

    fields.push({
      name,
      type: zodType._def.typeName,
      required: !isOptional(value as any),
      maxLength: checks.find((c: any) => c.kind === 'max')?.value,
      isUuid: checks.some((c: any) => c.kind === 'uuid'),
    });
  }

  return fields;
}

/**
 * Unwrap optional/nullable/default
 */
function unwrap(schema: any): any {
  const typeName = schema._def.typeName;

  if (typeName === 'ZodOptional' || typeName === 'ZodNullable' || typeName === 'ZodDefault') {
    return unwrap(schema._def.innerType ?? schema._def.type);
  }

  return schema;
}

/**
 * Check if optional
 */
function isOptional(schema: any): boolean {
  const typeName = schema._def.typeName;
  return typeName === 'ZodOptional' || typeName === 'ZodNullable';
}

/**
 * Convert field to Drizzle column definition
 */
function fieldToColumn(field: {
  name: string;
  type: string;
  required: boolean;
  maxLength?: number;
  isUuid?: boolean;
}): string {
  const columnName = toSnakeCase(field.name);
  let def: string;

  switch (field.type) {
    case 'ZodString':
      if (field.isUuid) {
        def = `uuid('${columnName}')`;
      } else if (field.maxLength && field.maxLength <= 255) {
        def = `varchar('${columnName}', { length: ${field.maxLength} })`;
      } else {
        def = `text('${columnName}')`;
      }
      break;

    case 'ZodNumber':
      def = `integer('${columnName}')`;
      break;

    case 'ZodBoolean':
      def = `boolean('${columnName}')`;
      break;

    case 'ZodDate':
      def = `timestamp('${columnName}', { withTimezone: true })`;
      break;

    case 'ZodArray':
    case 'ZodObject':
    case 'ZodRecord':
      def = `jsonb('${columnName}')`;
      break;

    default:
      def = `text('${columnName}')`;
  }

  if (field.required) {
    def += '.notNull()';
  }

  return def;
}

/**
 * Generate SQL schema (for migrations)
 */
export function generateSQLSchema(
  resources: ResourceDefinition[],
  options: SchemaOptions = {}
): GeneratedFile {
  const { outputFile = 'schema.sql', tenantColumn = 'tenant_id', timestamps = true } = options;

  const lines: string[] = ['-- Auto-generated by @mtpc/codegen', '-- Do not edit manually', ''];

  for (const resource of resources) {
    const tableName = toSnakeCase(resource.name);

    lines.push(`-- ${resource.metadata.displayName ?? resource.name}`);
    lines.push(`CREATE TABLE IF NOT EXISTS ${tableName} (`);
    lines.push('  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),');
    lines.push(`  ${tenantColumn} UUID NOT NULL,`);

    const fields = extractSchemaFields(resource.schema);
    for (const field of fields) {
      if (field.name === 'id' || field.name === 'tenantId') continue;

      const columnName = toSnakeCase(field.name);
      const sqlType = fieldToSQLType(field);
      const nullable = field.required ? ' NOT NULL' : '';
      lines.push(`  ${columnName} ${sqlType}${nullable},`);
    }

    if (timestamps) {
      lines.push('  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,');
      lines.push('  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,');
    }

    if (resource.features.advanced.softDelete) {
      lines.push('  deleted_at TIMESTAMP WITH TIME ZONE,');
    }

    // Remove trailing comma
    const lastLine = lines[lines.length - 1];
    lines[lines.length - 1] = lastLine.slice(0, -1);

    lines.push(');');
    lines.push('');
    lines.push(
      `CREATE INDEX IF NOT EXISTS ${tableName}_tenant_idx ON ${tableName}(${tenantColumn});`
    );
    lines.push('');
  }

  return {
    path: outputFile,
    content: lines.join('\n'),
    type: 'sql',
  };
}

/**
 * Convert field to SQL type
 */
function fieldToSQLType(field: { type: string; maxLength?: number; isUuid?: boolean }): string {
  switch (field.type) {
    case 'ZodString':
      if (field.isUuid) return 'UUID';
      if (field.maxLength) return `VARCHAR(${field.maxLength})`;
      return 'TEXT';
    case 'ZodNumber':
      return 'INTEGER';
    case 'ZodBoolean':
      return 'BOOLEAN';
    case 'ZodDate':
      return 'TIMESTAMP WITH TIME ZONE';
    case 'ZodArray':
    case 'ZodObject':
    case 'ZodRecord':
      return 'JSONB';
    default:
      return 'TEXT';
  }
}
