/**
 * Template renderer
 */
export class TemplateRenderer {
  private templates: Map<string, string> = new Map();

  /**
   * Register template
   */
  register(name: string, template: string): void {
    this.templates.set(name, template);
  }

  /**
   * Render template
   */
  render(name: string, context: Record<string, unknown>): string {
    const template = this.templates.get(name);

    if (!template) {
      throw new Error(`Template not found: ${name}`);
    }

    return this.interpolate(template, context);
  }

  /**
   * Interpolate variables in template
   */
  private interpolate(template: string, context: Record<string, unknown>): string {
    return template.replace(/\{\{\s*([\w.]+)\s*\}\}/g, (_, key) => {
      const value = this.getNestedValue(context, key);
      return value !== undefined ? String(value) : '';
    });
  }

  /**
   * Get nested value from object
   */
  private getNestedValue(obj: Record<string, unknown>, path: string): unknown {
    const keys = path.split('.');
    let current: unknown = obj;

    for (const key of keys) {
      if (current === null || current === undefined) {
        return undefined;
      }
      current = (current as Record<string, unknown>)[key];
    }

    return current;
  }
}

/**
 * Create template renderer with default templates
 */
export function createTemplateRenderer(): TemplateRenderer {
  const renderer = new TemplateRenderer();

  // Header template
  renderer.register(
    'header',
    `// Auto-generated by @mtpc/codegen
// Generated at: {{ timestamp }}
// Do not edit manually
`
  );

  // Permission const template
  renderer.register('permission-const', `export const {{ name }} = '{{ code }}' as const;`);

  // Type export template
  renderer.register('type-export', `export type {{ name }} = {{ type }};`);

  return renderer;
}
