---
title: mtpc/policy-cache 策略缓存扩展
description: 详细介绍策略缓存扩展的功能和使用方法
---

# @mtpc/policy-cache 策略缓存扩展

`@mtpc/policy-cache` 用于优化 **Policy Evaluation** 的运行时性能，尤其在多租户环境、权限策略复杂、高频权限校验场景。

## 扩展概述

### 为什么需要策略缓存

在多租户、高并发的应用中，权限检查是高频操作。每次权限检查都需要：

1. 解析权限定义
2. 查询角色和权限
3. 计算有效权限
4. 评估策略规则

这些操作如果每次都从头执行，会造成明显的性能开销。策略缓存可以：

- 减少数据库查询
- 降低 CPU 使用
- 提高响应速度
- 支持更高的并发量

### 缓存策略类型

| 策略 | 描述 | 适用场景 |
|------|------|----------|
| Write-Through（直写） | 每次更新都同步写入缓存 | 读多写少 |
| Write-Behind（回写） | 异步写入缓存，先写内存 | 写多读少 |
| Refresh-Ahead（预刷新） | 提前刷新即将过期的缓存 | 有过期时间要求 |

### 适用场景

- 多租户 SaaS 应用
- 高并发 API 服务
- 复杂的权限策略
- 频繁的权限检查
- 需要快速响应的系统

## 缓存策略

### Write-Through（直写）

写入时同步更新缓存，确保缓存与数据源一致。

```ts
import { createPolicyCache } from '@mtpc/policy-cache'

const cache = createPolicyCache({
  strategy: 'write-through',
  ttl: 300000, // 5 分钟
})
```

**特点：**

- 写入时同步更新缓存
- 缓存与数据源强一致
- 适合读多写少的场景

### Write-Behind（回写）

写入时异步更新缓存，先写内存，提高写入性能。

```ts
import { createPolicyCache } from '@mtpc/policy-cache'

const cache = createPolicyCache({
  strategy: 'write-behind',
  ttl: 300000,
  writeInterval: 5000, // 5 秒批量写入
})
```

**特点：**

- 写入时异步更新缓存
- 提高写入性能
- 适合写多读少的场景
- 可能有短暂的不一致

### Refresh-Ahead（预刷新）

在缓存过期前提前刷新，避免缓存失效时的延迟。

```ts
import { createPolicyCache } from '@mtpc/policy-cache'

const cache = createPolicyCache({
  strategy: 'refresh-ahead',
  ttl: 300000,
  refreshAheadRatio: 0.8, // 剩余 80% 时间时刷新
})
```

**特点：**

- 提前刷新缓存
- 避免缓存失效延迟
- 适合有过期时间要求的场景

## API 参考

### PolicyCache 类

```ts
class PolicyCache {
  constructor(options?: PolicyCacheOptions)
  
  // 获取权限
  async getPermissions(
    tenantId: string,
    subjectId: string
  ): Promise<Set<string>>
  
  // 使缓存失效
  async invalidate(
    tenantId: string,
    subjectId?: string
  ): Promise<void>
  
  // 清空缓存
  async clear(): Promise<void>
}
```

### CacheManager 接口

```ts
interface CacheManager {
  get(key: string): Promise<Set<string> | undefined>
  set(key: string, value: Set<string>, ttl: number): Promise<void>
  delete(key: string): Promise<void>
  clear(): Promise<void>
}
```

### 缓存配置选项

```ts
interface PolicyCacheOptions {
  strategy?: 'write-through' | 'write-behind' | 'refresh-ahead';
  ttl?: number;                    // 默认 300000 (5 分钟)
  maxSize?: number;                 // 默认 1000
  writeInterval?: number;            // 默认 5000 (write-behind)
  refreshAheadRatio?: number;       // 默认 0.8 (refresh-ahead)
}
```

## 集成方式

### 作为 MTPC 插件

```ts
import { createMTPC } from '@mtpc/core'
import { createPolicyCachePlugin } from '@mtpc/policy-cache'

// 创建策略缓存插件
const cachePlugin = createPolicyCachePlugin({
  ttl: 300000,
  strategy: 'write-through',
})

// 创建 MTPC 实例
const mtpc = createMTPC()

// 注册插件
mtpc.use(cachePlugin)

await mtpc.init()
```

### 自定义缓存实现

```ts
import { createPolicyCache } from '@mtpc/policy-cache'
import { Redis } from 'ioredis'

// 自定义 Redis 缓存管理器
const redisCache: CacheManager = {
  async get(key) {
    const data = await redis.get(key)
    return data ? new Set(JSON.parse(data)) : undefined
  },
  async set(key, value, ttl) {
    await redis.setex(key, ttl, JSON.stringify(Array.from(value)))
  },
  async delete(key) {
    await redis.del(key)
  },
  async clear() {
    await redis.flushdb()
  },
}

const cache = createPolicyCache({
  cacheManager: redisCache,
  ttl: 300000,
})
```

## 使用示例

### 启用策略缓存

```ts
import { createMTPC } from '@mtpc/core'
import { createPolicyCachePlugin } from '@mtpc/policy-cache'

// 创建策略缓存插件
const cachePlugin = createPolicyCachePlugin({
  ttl: 300000, // 5 分钟缓存
  strategy: 'write-through',
})

// 创建 MTPC 实例
const mtpc = createMTPC()

// 注册插件
mtpc.use(cachePlugin)

await mtpc.init()

console.log('策略缓存已启用')
```

### 配置缓存策略

```ts
import { createPolicyCachePlugin } from '@mtpc/policy-cache'

// 使用 write-behind 策略
const cachePlugin = createPolicyCachePlugin({
  strategy: 'write-behind',
  ttl: 300000,
  writeInterval: 5000, // 5 秒批量写入
})

// 使用 refresh-ahead 策略
const refreshAheadPlugin = createPolicyCachePlugin({
  strategy: 'refresh-ahead',
  ttl: 300000,
  refreshAheadRatio: 0.8, // 剩余 80% 时间时刷新
})
```

### 缓存失效

```ts
import { createPolicyCachePlugin } from '@mtpc/policy-cache'

const cachePlugin = createPolicyCachePlugin()

// 注册插件
mtpc.use(cachePlugin)

// 角色变更后使缓存失效
await rbac.updateRole('tenant-001', 'role-001', {
  permissions: ['new:permission'],
})

// 使相关用户的缓存失效
await cachePlugin.state.cache.invalidate('tenant-001', 'user-123')

// 或者使整个租户的缓存失效
await cachePlugin.state.cache.invalidate('tenant-001')
```

### 清空缓存

```ts
// 清空所有缓存
await cachePlugin.state.cache.clear()

console.log('所有缓存已清空')
```

## 性能优化建议

### 缓存 TTL 设置

根据权限变更频率设置合适的 TTL：

| 变更频率 | 推荐的 TTL |
|----------|-----------|
| 极少（分钟级）| 600000 (10 分钟) |
| 较少（小时级） | 300000 (5 分钟) |
| 中等（天级） | 180000 (3 分钟) |
| 频繁（分钟级）| 60000 (1 分钟) |

### 缓存大小限制

设置合理的缓存大小限制，避免内存溢出：

```ts
const cachePlugin = createPolicyCachePlugin({
  maxSize: 1000, // 最多缓存 1000 个权限集
  ttl: 300000,
})
```

### 批量权限检查

使用批量权限检查减少缓存查询次数：

```ts
// 批量检查权限
const results = await mtpc.checkPermissions([
  { tenant, subject, resource: 'user', action: 'create' },
  { tenant, subject, resource: 'user', action: 'read' },
  { tenant, subject, resource: 'user', action: 'update' },
])

// 只查询一次缓存
```

### 监控缓存命中率

监控缓存命中率以优化缓存配置：

```ts
import { createPolicyCachePlugin } from '@mtpc/policy-cache'

const cachePlugin = createPolicyCachePlugin({
  onHit: (key) => {
    console.log('缓存命中:', key)
  },
  onMiss: (key) => {
    console.log('缓存未命中:', key)
  },
})
```

---

**继续学习：** [@mtpc/explain](/docs/extensions/explain) →
